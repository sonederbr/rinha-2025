using System;
using System.Collections.Concurrent;
using System.Net;
using System.Net.Http.Json;
using System.Net.Security;
using System.Threading;
using System.Threading.Channels;
using System.Threading.Tasks;
using Polly;
using Polly.CircuitBreaker;
using Polly.Timeout;
using Polly.Wrap;
using Microsoft.AspNetCore.Builder;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using System.Collections.Generic;

var builder = WebApplication.CreateBuilder(args);

const string paymentProcessorDefaultUrl = "http://localhost:8001";
const string paymentProcessorFallbackUrl = "http://localhost:8002";

ThreadPool.SetMinThreads(workerThreads: 512, completionPortThreads: 512);

builder.WebHost.ConfigureKestrel(options =>
{
    options.Limits.MaxConcurrentConnections = 1024;
    options.Limits.MaxConcurrentUpgradedConnections = 1024;
    options.Limits.MaxRequestLineSize = 8192;
});

SocketsHttpHandler CreateHttpHandler() => new()
{
    SslOptions = new SslClientAuthenticationOptions
    {
        RemoteCertificateValidationCallback = (_, _, _, _) => true
    },
    PooledConnectionLifetime = TimeSpan.FromMinutes(5),
    PooledConnectionIdleTimeout = TimeSpan.FromMinutes(2),
    MaxConnectionsPerServer = 512,
    AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate
};

builder.Services.AddHttpClient(Constants.DefaultClient, httpClient =>
    {
        httpClient.BaseAddress = new Uri(paymentProcessorDefaultUrl);
        httpClient.DefaultRequestHeaders.Add(Constants.HeaderClientSourceName, Constants.DefaultClient);
        httpClient.Timeout = Timeout.InfiniteTimeSpan;
    })
    .ConfigurePrimaryHttpMessageHandler(CreateHttpHandler)
    .SetHandlerLifetime(TimeSpan.FromMinutes(5));

builder\Services.AddHttpClient(Constants.FallbackClient, httpClient =>
    {
        httpClient.BaseAddress = new Uri(paymentProcessorFallbackUrl);
        httpClient.DefaultRequestHeaders.Add(Constants.HeaderClientSourceName, Constants.FallbackClient);
        httpClient.Timeout = Timeout.InfiniteTimeSpan;
    })
    .ConfigurePrimaryHttpMessageHandler(CreateHttpHandler)
    .SetHandlerLifetime(TimeSpan.FromMinutes(5));

var paymentChannel = Channel.CreateBounded<PaymentRequest>(new BoundedChannelOptions(2048)
{
    SingleReader = false,
    SingleWriter = false,
    FullMode = BoundedChannelFullMode.Wait
});
var defaultProcessorHealth = new PaymentProcessorHealth();
var fallbackProcessorHealth = new PaymentProcessorHealth();
var paymentsDefault = new ConcurrentBag<PaymentResponse>();
var paymentsFallback = new ConcurrentBag<PaymentResponse>();

builder.Services.AddOpenApi();
builder.Services.AddSingleton<PaymentProcessor>(provider => new PaymentProcessor(
    provider.GetRequiredService<IHttpClientFactory>(), 
    defaultProcessorHealth, 
    fallbackProcessorHealth));
builder.Services.AddSingleton<HealthCheckProcessor>();

builder.Services.AddHostedService<HealthCheckWorker>(provider => new HealthCheckWorker(
    provider.GetRequiredService<HealthCheckProcessor>(),
    defaultProcessorHealth,
    fallbackProcessorHealth,
    TimeSpan.FromSeconds(Constants.HealthCheckIntervalInSeconds)));

var processorCount = Environment.ProcessorCount * 3;
for (var i = 0; i < processorCount; i++)
{
    builder.Services.AddHostedService<PaymentWorker>(provider => new PaymentWorker(
        paymentChannel,
        provider.GetRequiredService<PaymentProcessor>(),
        paymentsDefault,
        paymentsFallback));
}

var app = builder.Build();

app.MapPost("/payments", (PaymentRequest payment) =>
{
    if (string.IsNullOrWhiteSpace(payment.CorrelationId) || payment.Amount <= 0)
        return Results.BadRequest("Invalid payment request.");

    if (!paymentChannel.Writer.TryWrite(payment))
        return Results.StatusCode(503);

    return Results.Accepted($"/payments/{payment.CorrelationId}",
        new { Message = "Payment accepted for processing." });
});

app.MapGet("/payments-summary", (HttpRequest req) =>
{
    var fromStr = req.Query["from"].ToString();
    var toStr = req.Query["to"].ToString();

    DateTimeOffset? from = null;
    DateTimeOffset? to = null;

    if (DateTimeOffset.TryParse(fromStr, out var parsedFrom))
        from = parsedFrom;

    if (DateTimeOffset.TryParse(toStr, out var parsedTo))
        to = parsedTo;

    var filteredDefault = paymentsDefault
        .Where(p => (!from.HasValue || p.RequestedAt >= from) && (!to.HasValue || p.RequestedAt <= to))
        .ToList();

    var filteredFallback = paymentsFallback
        .Where(p => (!from.HasValue || p.RequestedAt >= from) && (!to.HasValue || p.RequestedAt <= to))
        .ToList();

    return Results.Ok(new
    {
        @default = new
        {
            totalRequests = filteredDefault.Count,
            totalAmount = filteredDefault.Sum(p => p.Amount)
        },
        fallback = new
        {
            totalRequests = filteredFallback.Count,
            totalAmount = filteredFallback.Sum(p => p.Amount)
        }
    });
});

app.Run();

#region Payment processor

public class PaymentProcessor
{
    private readonly IHttpClientFactory _httpClientFactory;
    private AsyncPolicyWrap<HttpResponseMessage>? _defaultPolicy;
    private AsyncPolicy<HttpResponseMessage>? _fallbackPolicy;
    private readonly PaymentProcessorHealth _defaultHealth;
    private readonly PaymentProcessorHealth _fallbackHealth;

    public PaymentProcessor(IHttpClientFactory httpClientFactory, PaymentProcessorHealth defaultHealth, PaymentProcessorHealth fallbackHealth)
    {
        _httpClientFactory = httpClientFactory;
        _defaultHealth = defaultHealth;
        _fallbackHealth = fallbackHealth;
        ConfigureRetryPolices();
    }

    public async Task ProcessTransactionAsync(
        PaymentRequest payment,
        ConcurrentBag<PaymentResponse> paymentsDefault,
        ConcurrentBag<PaymentResponse> paymentsFallback,
        Channel<PaymentRequest> paymentChannel,
        CancellationToken cancellationToken)
    {
        var requestedAt = DateTime.UtcNow;
        var payload = new
        {
            payment.CorrelationId,
            payment.Amount,
            RequestedAt = requestedAt.ToString("o")
        };
        var (response, usedClient) = await SendTransaction(payload, cancellationToken);
        if (response)
        {
            var paymentResponse = new PaymentResponse(payment.Amount, requestedAt);
            switch (usedClient)
            {
                case Constants.DefaultClient:
                    paymentsDefault.Add(paymentResponse);
                    break;
                case Constants.FallbackClient:
                    paymentsFallback.Add(paymentResponse);
                    break;
            }
        }
        else if (payment.RetryCount < 5)
        {
            payment.RetryCount++;
            if (paymentChannel.Writer.TryWrite(payment))
            {
                Console.WriteLine($"Requeued payment {payment.CorrelationId} (Retry {payment.RetryCount})");
            }
            else
            {
                Console.WriteLine($"Failed to requeue payment {payment.CorrelationId}: Queue full");
            }
        }
        else
        {
            Console.WriteLine($"Payment {payment.CorrelationId} failed after {payment.RetryCount} retries");
        }
    }

    private async Task<(bool response, string usedClient)> SendTransaction(object payload, CancellationToken cancellationToken)
    {
        try
        {
            if (ShouldUseFallback())
                return await SendToFallbackAsync(payload, cancellationToken);
            return await SendToDefaultAsync(payload, cancellationToken);
        }
        catch (Exception e)
        {
            Console.WriteLine("SendTransaction: " + e.Message);
        }
        return (false, string.Empty);
    }

    private async Task<(bool IsSuccessStatusCode, string usedPolicy)> SendToDefaultAsync(object payload,
        CancellationToken cancellationToken)
    {
        var client = GetClient(Constants.DefaultClient);
        var context = new Context { ["payload"] = payload, ["LastPolicy"] = Constants.DefaultClient };
        var response = await _defaultPolicy!.ExecuteAsync((_, ct) =>
            client.PostAsJsonAsync("/payments", payload, ct), context, cancellationToken);
        var usedPolicy = context.TryGetValue("LastPolicy", out var value) ? value.ToString() : "Unknown";
        if (!usedPolicy!.Equals(Constants.DefaultClient))
            Console.WriteLine(
                $"Send to: {Constants.DefaultClient} executed on {usedPolicy} and is {response.IsSuccessStatusCode}");
        return (response.IsSuccessStatusCode, usedPolicy);
    }

    private async Task<(bool IsSuccessStatusCode, string usedPolicy)> SendToFallbackAsync(object payload,
        CancellationToken cancellationToken)
    {
        var client = GetClient(Constants.FallbackClient);
        var context = new Context { ["payload"] = payload, ["LastPolicy"] = Constants.FallbackClient };
        var response = await _fallbackPolicy!.ExecuteAsync((_, ct) =>
            client.PostAsJsonAsync("/payments", payload, ct), context, cancellationToken);
        var usedPolicy = context.TryGetValue("LastPolicy", out var value) ? value.ToString() : "Unknown";
        if (!usedPolicy!.Equals(Constants.FallbackClient))
            Console.WriteLine(
                $"Send to: {Constants.FallbackClient} executed on {usedPolicy} and is {response.IsSuccessStatusCode}");
        return (response.IsSuccessStatusCode, usedPolicy);
    }

    private void ConfigureRetryPolices()
    {
        int defaultRetries = 5;
        int fallbackRetries = 5;
        double toleranceFactor = 1.5;

        var defaultTimeout = Policy.TimeoutAsync<HttpResponseMessage>(
            TimeSpan.FromSeconds(Math.Max(3.5, _defaultHealth.MinResponseTime / 1000.0 * toleranceFactor)),
            TimeoutStrategy.Optimistic
        );

        var fallbackTimeout = Policy.TimeoutAsync<HttpResponseMessage>(
            TimeSpan.FromSeconds(Math.Max(2.0, _fallbackHealth.MinResponseTime / 1000.0 * toleranceFactor)),
            TimeoutStrategy.Optimistic
        );

        var defaultCircuitBreaker = Policy<HttpResponseMessage>
            .Handle<Exception>()
            .OrResult(r => !r.IsSuccessStatusCode)
            .CircuitBreakerAsync(
                exceptionsAllowedBeforeBreaking: 3,
                durationOfBreak: TimeSpan.FromSeconds(30),
                onBreak: (result, breakDuration, context) =>
                    Console.WriteLine($"Default circuit breaker opened for {breakDuration.TotalSeconds}s"),
                onReset: () => Console.WriteLine("Default circuit breaker reset")
            );

        var fallbackCircuitBreaker = Policy<HttpResponseMessage>
            .Handle<Exception>()
            .OrResult(r => !r.IsSuccessStatusCode)
            .CircuitBreakerAsync(
                exceptionsAllowedBeforeBreaking: 3,
                durationOfBreak: TimeSpan.FromSeconds(30),
                onBreak: (result, breakDuration, context) =>
                    Console.WriteLine($"Fallback circuit breaker opened for {breakDuration.TotalSeconds}s"),
                onReset: () => Console.WriteLine("Fallback circuit breaker reset")
            );

        var defaultRetryPolicy = Policy<HttpResponseMessage>
            .Handle<Exception>()
            .OrResult(r => !r.IsSuccessStatusCode)
            .WaitAndRetryAsync(
                retryCount: defaultRetries,
                sleepDurationProvider: attempt => TimeSpan.FromSeconds(Math.Pow(2, attempt) + Random.Shared.NextDouble()),
                onRetryAsync: async (_, _, _, context) =>
                {
                    context["LastPolicy"] = Constants.DefaultClient;
                    await Task.CompletedTask;
                }
            );

        var fallbackRetryPolicy = Policy<HttpResponseMessage>
            .Handle<Exception>()
            .OrResult(r => !r.IsSuccessStatusCode)
            .WaitAndRetryAsync(
                retryCount: fallbackRetries,
                sleepDurationProvider: attempt => TimeSpan.FromSeconds(Math.Pow(2, attempt) + Random.Shared.NextDouble()),
                onRetryAsync: async (_, _, _, context) =>
                {
                    context["LastPolicy"] = Constants.FallbackClient;
                    await Task.CompletedTask;
                }
            );

        var defaultBulkhead = Policy.BulkheadAsync<HttpResponseMessage>(512, int.MaxValue);
        var fallbackBulkhead = Policy.BulkheadAsync<HttpResponseMessage>(512, int.MaxValue);

        var defaultWithTimeout = defaultRetryPolicy.WrapAsync(defaultTimeout).WrapAsync(defaultCircuitBreaker).WrapAsync(defaultBulkhead);
        var fallbackWithTimeout = fallbackRetryPolicy.WrapAsync(fallbackTimeout).WrapAsync(fallbackCircuitBreaker).WrapAsync(fallbackBulkhead);

        _defaultPolicy = defaultWithTimeout.WrapAsync(fallbackWithTimeout); // Default > Fallback apenas
        _fallbackPolicy = fallbackWithTimeout; // Apenas Fallback
    }

    private bool ShouldUseFallback()
    {
        if (!_defaultHealth.IsHealthy && _fallbackHealth.IsHealthy)
            return true;

        if (!_fallbackHealth.IsHealthy && _defaultHealth.IsHealthy)
            return false;

        if (!_defaultHealth.IsHealthy && !_fallbackHealth.IsHealthy)
        {
            return _fallbackHealth.MinResponseTime < _defaultHealth.MinResponseTime;
        }

        var toleranceFactor = 1.5;
        if (_defaultHealth.IsHealthy && _fallbackHealth.IsHealthy && 
            _defaultHealth.MinResponseTime > (int)(toleranceFactor * _fallbackHealth.MinResponseTime))
            return true;

        return false;
    }

    private HttpClient GetClient(string clientName)
    {
        return _httpClientFactory.CreateClient(clientName);
    }
}

public class PaymentWorker(
    Channel<PaymentRequest> channel,
    PaymentProcessor processor,
    ConcurrentBag<PaymentResponse> paymentsDefault,
    ConcurrentBag<PaymentResponse> paymentsFallback)
    : BackgroundService
{
    protected override async Task ExecuteAsync(CancellationToken cancellationToken)
    {
        await foreach (var payment in channel.Reader.ReadAllAsync(cancellationToken))
        {
            try
            {
                await ProcessPaymentAsync(payment, cancellationToken);
            }
            catch
            {
                // Ignored, reenfileiramento tratado em ProcessTransactionAsync
            }
        }
    }

    private async Task ProcessPaymentAsync(PaymentRequest payment, CancellationToken cancellationToken)
    {
        await processor.ProcessTransactionAsync(
            payment,
            paymentsDefault,
            paymentsFallback,
            channel,
            cancellationToken);
    }
}

#endregion

#region Health check

public class HealthCheckWorker(
    HealthCheckProcessor healthCheckProcessor,
    PaymentProcessorHealth defaultHealth,
    PaymentProcessorHealth fallbackHealth,
    TimeSpan interval)
    : BackgroundService
{
    protected override async Task ExecuteAsync(CancellationToken cancellationToken)
    {
        var defaultTask = CheckAsync(Constants.DefaultClient, defaultHealth, cancellationToken);
        var fallbackTask = CheckAsync(Constants.FallbackClient, fallbackHealth, cancellationToken);
        await Task.WhenAll(defaultTask, fallbackTask);
    }

    private async Task CheckAsync(string client, PaymentProcessorHealth health, CancellationToken cancellationToken)
    {
        while (!cancellationToken.IsCancellationRequested)
        {
            try
            {
                await healthCheckProcessor.HealthCheckAsync(client, health, cancellationToken);
            }
            catch
            {
                // Ignored
            }

            await Task.Delay(interval + TimeSpan.FromMilliseconds(Random.Shared.Next(1000)), cancellationToken);
        }
    }
}

public class HealthCheckProcessor(IHttpClientFactory httpClientFactory)
{
    internal async Task HealthCheckAsync(
        string client,
        PaymentProcessorHealth health,
        CancellationToken cancellationToken = default)
    {
        try
        {
            var httpClient = httpClientFactory.CreateClient(client);
            httpClient.Timeout = TimeSpan.FromSeconds(Math.Max(2, health.MinResponseTime / 1000.0 * 1.5));
            var response = await httpClient.GetFromJsonAsync<HealthStatus>(
                "payments/service-health",
                cancellationToken: cancellationToken);

            if (response != null)
            {
                health.IsHealthy = !response.Failing;
                health.MinResponseTime = response.MinResponseTime;
            }
        }
        catch
        {
            health.IsHealthy = false;
            health.MinResponseTime = int.MaxValue;
        }
    }
}

#endregion

#region Models

public record PaymentRequest(string CorrelationId, decimal Amount, int RetryCount = 0);

public record PaymentResponse(decimal Amount, DateTimeOffset RequestedAt);

record HealthStatus(bool Failing, int MinResponseTime);

public class PaymentProcessorHealth
{
    private readonly ReaderWriterLockSlim _lock = new();
    private bool _isHealthy;

    public bool IsHealthy
    {
        get
        {
            _lock.EnterReadLock();
            try
            {
                return _isHealthy;
            }
            finally
            {
                _lock.ExitReadLock();
            }
        }
        set
        {
            _lock.EnterWriteLock();
            try
            {
                _isHealthy = value;
            }
            finally
            {
                _lock.ExitWriteLock();
            }
        }
    }

    public bool IsBreakerOpen { get; set; }
    public int MinResponseTime { get; set; }
}

internal static class Constants
{
    internal const string HeaderClientSourceName = "X-Client-Source";
    internal const string DefaultClient = "DefaultUrl";
    internal const string FallbackClient = "FallbackUrl";
    internal const ushort HealthCheckIntervalInSeconds = 5;
    internal const ushort QueueLimit = 1024;
    internal const ushort HttpTimeoutInSeconds = 45;
}

#endregion