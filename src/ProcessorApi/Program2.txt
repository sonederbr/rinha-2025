using System.Net;
using System.Net.Security;
using System.Threading.Channels;
using Polly;
using Polly.Timeout;
using Polly.Wrap;

var builder = WebApplication.CreateBuilder(args);

const string paymentProcessorDefaultUrl = "http://localhost:8001";
const string paymentProcessorFallbackUrl = "http://localhost:8002";


ThreadPool.SetMinThreads(workerThreads: 512, completionPortThreads: 512);

builder.WebHost.ConfigureKestrel(options =>
{
    options.Limits.MaxConcurrentConnections = 1024;
    options.Limits.MaxConcurrentUpgradedConnections = 1024;
    options.Limits.MaxRequestLineSize = 8192;
});


SocketsHttpHandler CreateHttpHandler() => new()
{
    SslOptions = new SslClientAuthenticationOptions
    {
        RemoteCertificateValidationCallback = (_, _, _, _) => true
    },
    PooledConnectionLifetime = TimeSpan.FromMinutes(5),
    PooledConnectionIdleTimeout = TimeSpan.FromMinutes(2),
    MaxConnectionsPerServer = 1024,
    AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate
};

builder.Services.AddHttpClient(Constants.DefaultClient, httpClient =>
    {
        httpClient.BaseAddress = new Uri(paymentProcessorDefaultUrl);
        httpClient.DefaultRequestHeaders.Add(Constants.HeaderClientSourceName, Constants.DefaultClient);
        httpClient.Timeout = Timeout.InfiniteTimeSpan;
    })
    .ConfigurePrimaryHttpMessageHandler(CreateHttpHandler)
    .SetHandlerLifetime(TimeSpan.FromMinutes(5));

builder.Services.AddHttpClient(Constants.FallbackClient, httpClient =>
    {
        httpClient.BaseAddress = new Uri(paymentProcessorFallbackUrl);
        httpClient.DefaultRequestHeaders.Add(Constants.HeaderClientSourceName, Constants.FallbackClient);
        httpClient.Timeout = Timeout.InfiniteTimeSpan;
    })
    .ConfigurePrimaryHttpMessageHandler(CreateHttpHandler)
    .SetHandlerLifetime(TimeSpan.FromMinutes(5));

var paymentChannel = Channel.CreateBounded<PaymentRequest>(new BoundedChannelOptions(2048)
{
    SingleReader = false,
    SingleWriter = false,
    FullMode = BoundedChannelFullMode.Wait
});
var defaultProcessorHealth = new PaymentProcessorHealth();
var fallbackProcessorHealth = new PaymentProcessorHealth();
var paymentsDefault = new List<PaymentResponse>();
var paymentsFallback = new List<PaymentResponse>();

builder.Services.AddOpenApi();
builder.Services.AddSingleton<PaymentProcessor>(provider => new PaymentProcessor(
    provider.GetRequiredService<IHttpClientFactory>(), 
    defaultProcessorHealth, 
    fallbackProcessorHealth));
builder.Services.AddSingleton<HealthCheckProcessor>();

builder.Services.AddHostedService<HealthCheckWorker>(provider => new HealthCheckWorker(
    provider.GetRequiredService<HealthCheckProcessor>(),
    defaultProcessorHealth,
    fallbackProcessorHealth,
    TimeSpan.FromSeconds(Constants.HealthCheckIntervalInSeconds)));

var processorCount = Environment.ProcessorCount * 3;
for (var i = 0; i < processorCount; i++)
{
    builder.Services.AddHostedService<PaymentWorker>(provider => new PaymentWorker(
        paymentChannel,
        provider.GetRequiredService<PaymentProcessor>(),
        paymentsDefault,
        paymentsFallback));
}

var app = builder.Build();

app.MapPost("/payments", (PaymentRequest payment) =>
{
    if (string.IsNullOrWhiteSpace(payment.CorrelationId) || payment.Amount <= 0)
        return Results.BadRequest("Invalid payment request.");

    if (!paymentChannel.Writer.TryWrite(payment))
        return Results.StatusCode(503);

    return Results.Accepted($"/payments/{payment.CorrelationId}",
        new { Message = "Payment accepted for processing." });
});

app.MapGet("/payments-summary", (HttpRequest req) =>
{
    var fromStr = req.Query["from"].ToString();
    var toStr = req.Query["to"].ToString();

    DateTimeOffset? from = null;
    DateTimeOffset? to = null;

    if (DateTimeOffset.TryParse(fromStr, out var parsedFrom))
        from = parsedFrom;

    if (DateTimeOffset.TryParse(toStr, out var parsedTo))
        to = parsedTo;

    var filteredDefault = paymentsDefault
        .Where(p => (!from.HasValue || p.RequestedAt >= from) && (!to.HasValue || p.RequestedAt <= to))
        .ToList();

    var filteredFallback = paymentsFallback
        .Where(p => (!from.HasValue || p.RequestedAt >= from) && (!to.HasValue || p.RequestedAt <= to))
        .ToList();

    return Results.Ok(new
    {
        @default = new
        {
            totalRequests = filteredDefault.Count,
            totalAmount = filteredDefault.Sum(p => p.Amount)
        },
        fallback = new
        {
            totalRequests = filteredFallback.Count,
            totalAmount = filteredFallback.Sum(p => p.Amount)
        }
    });
});

app.Run();

#region Payment processor

public class PaymentProcessor
{
    private readonly IHttpClientFactory _httpClientFactory;

    private AsyncPolicyWrap<HttpResponseMessage>? _defaultPolicy;
    private AsyncPolicy<HttpResponseMessage>? _fallbackPolicy;
    private readonly PaymentProcessorHealth _defaultHealth;
    private readonly PaymentProcessorHealth _fallbackHealth;

    public PaymentProcessor(IHttpClientFactory httpClientFactory, PaymentProcessorHealth defaultHealth, PaymentProcessorHealth fallbackHealth)
    {
        _httpClientFactory = httpClientFactory;
        _defaultHealth = defaultHealth;
        _fallbackHealth = fallbackHealth;
        ConfigureRetryPolices();
    }

    public async Task ProcessTransactionAsync(
        PaymentRequest payment,
        List<PaymentResponse> paymentsDefault,
        List<PaymentResponse> paymentsFallback,
        CancellationToken cancellationToken)
    {
        var requestedAt = DateTime.UtcNow;
        var payload = new
        {
            payment.CorrelationId,
            payment.Amount,
            RequestedAt = requestedAt.ToString("o")
        };
        var (response, usedClient) = await SendTransaction(payload, cancellationToken);
        var paymentResponse = new PaymentResponse(payment.Amount, requestedAt);
        switch (usedClient)
        {
            case Constants.DefaultClient:
            {
                lock (paymentsDefault) paymentsDefault.Add(paymentResponse);
                break;
            }
            case Constants.FallbackClient:
            {
                lock (paymentsFallback) paymentsFallback.Add(paymentResponse);
                break;
            }
        }
        
        if(!response)
            Console.WriteLine("Transaction has not been processed.");
    }

    private async Task<(bool response, string usedClient)> SendTransaction(object payload, CancellationToken cancellationToken)
    {
        try
        {
            if (ShouldUseFallback())
                return await SendToFallbackAsync(payload, cancellationToken);
            return await SendToDefaultAsync(payload, cancellationToken);
        }
        catch (Exception e)
        {
            Console.WriteLine("SendTransaction: " + e.Message);
        }
        return (false, string.Empty);
    }

    private async Task<(bool IsSuccessStatusCode, string usedPolicy)> SendToDefaultAsync(object payload,
        CancellationToken cancellationToken)
    {
        var client = GetClient(Constants.DefaultClient);
        var context = new Context { ["payload"] = payload, ["LastPolicy"] = Constants.DefaultClient };
        var response = await _defaultPolicy!.ExecuteAsync((_, ct) =>
            client.PostAsJsonAsync("/payments", payload, ct), context, cancellationToken);
        var usedPolicy = context.TryGetValue("LastPolicy", out var value) ? value.ToString() : "Unknow";
        if (!usedPolicy!.Equals(Constants.DefaultClient))
            Console.WriteLine(
                $"Send to: {Constants.DefaultClient} executed on {usedPolicy} and is {response.IsSuccessStatusCode}");
        return (response.IsSuccessStatusCode, usedPolicy);
    }

    private async Task<(bool IsSuccessStatusCode, string usedPolicy)> SendToFallbackAsync(object payload,
        CancellationToken cancellationToken)
    {
        var client = GetClient(Constants.FallbackClient);
        var context = new Context { ["payload"] = payload, ["LastPolicy"] = Constants.FallbackClient };
        var response = await _fallbackPolicy!.ExecuteAsync((_, ct) =>
            client.PostAsJsonAsync("/payments", payload, ct), context, cancellationToken);
        var usedPolicy = context.TryGetValue("LastPolicy", out var value) ? value.ToString() : "Unknow";
        if (!usedPolicy!.Equals(Constants.FallbackClient))
            Console.WriteLine(
                $"Send to: {Constants.FallbackClient} executed on {usedPolicy} and is {response.IsSuccessStatusCode}");
        return (response.IsSuccessStatusCode, usedPolicy);
    }

    private void ConfigureRetryPolices()
    {
        int defaultRetries = 2; 
        double defaultTimeoutSeconds = 3.5; 
        double defaultSleepBase = 2;

        int fallbackRetries = 2; 
        double fallbackTimeoutSeconds = 2;
        double fallbackSleepBase = 2;

        var defaultTimeout = Policy.TimeoutAsync<HttpResponseMessage>(
            TimeSpan.FromSeconds(defaultTimeoutSeconds),
            TimeoutStrategy.Optimistic
        );

        var fallbackTimeout = Policy.TimeoutAsync<HttpResponseMessage>(
            TimeSpan.FromSeconds(fallbackTimeoutSeconds),
            TimeoutStrategy.Optimistic
        );

        var defaultRetryPolicy = Policy<HttpResponseMessage>
            .Handle<Exception>()
            .OrResult(r => !r.IsSuccessStatusCode)
            .WaitAndRetryAsync(
                retryCount: defaultRetries,
                sleepDurationProvider: attempt => TimeSpan.FromSeconds(defaultSleepBase * attempt),
                onRetryAsync: async (_, _, _, context) =>
                {
                    context["LastPolicy"] = Constants.DefaultClient;
                    await Task.CompletedTask;
                }
            );

        var fallbackRetryPolicy = Policy<HttpResponseMessage>
            .Handle<Exception>()
            .OrResult(r => !r.IsSuccessStatusCode)
            .WaitAndRetryAsync(
                retryCount: fallbackRetries,
                sleepDurationProvider: attempt => TimeSpan.FromSeconds(fallbackSleepBase * attempt),
                onRetryAsync: async (_, _, _, context) =>
                {
                    context["LastPolicy"] = Constants.FallbackClient;
                    await Task.CompletedTask;
                }
            );
        
        var defaultWithTimeout = defaultRetryPolicy.WrapAsync(defaultTimeout);
        var fallbackWithTimeout = fallbackRetryPolicy.WrapAsync(fallbackTimeout);
        
        var defaultWithFallback = defaultWithTimeout.WrapAsync(fallbackWithTimeout);
        var fallbackWithDefault = fallbackWithTimeout.WrapAsync(defaultWithTimeout);

        _defaultPolicy = defaultWithFallback.WrapAsync(fallbackWithDefault);
        _fallbackPolicy = fallbackWithDefault.WrapAsync(defaultWithFallback);
    }
    
    private bool ShouldUseFallback()
    {
        if (!_defaultHealth.IsHealthy)
            return true;
        
        if (!_fallbackHealth.IsHealthy)
            return false;
        
        var toleranceFactor = 1.5;
        if ((_defaultHealth.IsHealthy && _fallbackHealth.IsHealthy) && _defaultHealth.MinResponseTime >
            (int)(toleranceFactor * _fallbackHealth.MinResponseTime))
            return true;

        return false;
    }

    private HttpClient GetClient(string clientName)
    {
        return _httpClientFactory.CreateClient(clientName);
    }
}

public class PaymentWorker(
    Channel<PaymentRequest> channel,
    PaymentProcessor processor,
    List<PaymentResponse> paymentsDefault,
    List<PaymentResponse> paymentsFallback)
    : BackgroundService
{
    protected override async Task ExecuteAsync(CancellationToken cancellationToken)
    {
        await foreach (var payment in channel.Reader.ReadAllAsync(cancellationToken))
        {
            try
            {
                _ = ProcessPaymentAsync(payment, cancellationToken);
            }
            catch
            {
                // ignored
            }
        }
    }

    private async Task ProcessPaymentAsync(PaymentRequest payment, CancellationToken cancellationToken)
    {
        await processor.ProcessTransactionAsync(
            payment,
            paymentsDefault,
            paymentsFallback,
            cancellationToken);
    }
}

#endregion

#region Health check

public class HealthCheckWorker(
    HealthCheckProcessor healthCheckProcessor,
    PaymentProcessorHealth defaultHealth,
    PaymentProcessorHealth fallbackHealth,
    TimeSpan interval)
    : BackgroundService
{
    protected override async Task ExecuteAsync(CancellationToken cancellationToken)
    {
        var defaultTask = CheckAsync(Constants.DefaultClient, defaultHealth, cancellationToken);
        var fallbackTask = CheckAsync(Constants.FallbackClient, fallbackHealth, cancellationToken);
        await Task.WhenAll(defaultTask, fallbackTask);
    }

    private async Task CheckAsync(string client, PaymentProcessorHealth health, CancellationToken cancellationToken)
    {
        while (!cancellationToken.IsCancellationRequested)
        {
            try
            {
                await healthCheckProcessor.HealthCheckAsync(client, health, cancellationToken);
            }
            catch
            {
                // ignored
            }

            await Task.Delay(interval, cancellationToken);
        }
    }
}

public class HealthCheckProcessor(IHttpClientFactory httpClientFactory)
{
    internal async Task HealthCheckAsync(
        string client,
        PaymentProcessorHealth health,
        CancellationToken cancellationToken = default)
    {
        try
        {
            var httpClient = httpClientFactory.CreateClient(client);
            httpClient.Timeout = TimeSpan.FromSeconds(2);
            var response = await httpClient.GetFromJsonAsync<HealthStatus>(
                "payments/service-health",
                cancellationToken: cancellationToken);

            if (response != null)
            {
                health.IsHealthy = !response.Failing;
                health.MinResponseTime = response.MinResponseTime;
            }
        }
        catch
        {
            health.IsHealthy = false;
            health.MinResponseTime = int.MaxValue;
        }
    }
}

#endregion

#region Models

// ReSharper disable once ClassNeverInstantiated.Global
public record PaymentRequest(string CorrelationId, decimal Amount);

public record PaymentResponse(decimal Amount, DateTimeOffset RequestedAt);

record HealthStatus(bool Failing, int MinResponseTime);

public class PaymentProcessorHealth
{
    private readonly ReaderWriterLockSlim _lock = new();
    private bool _isHealthy;

    public bool IsHealthy
    {
        get
        {
            _lock.EnterReadLock();
            try
            {
                return _isHealthy;
            }
            finally
            {
                _lock.ExitReadLock();
            }
        }
        set
        {
            _lock.EnterWriteLock();
            try
            {
                _isHealthy = value;
            }
            finally
            {
                _lock.ExitWriteLock();
            }
        }
    }

    public bool IsBreakerOpen { get; set; }
    public int MinResponseTime { get; set; }
}

internal static class Constants
{
    internal const string HeaderClientSourceName = "X-Client-Source";
    internal const string DefaultClient = "DefaultUrl";
    internal const string FallbackClient = "FallbackUrl";
    internal const ushort HealthCheckIntervalInSeconds = 5;
    internal const ushort QueueLimit = 1024;
    internal const ushort HttpTimeoutInSeconds = 45;
}

#endregion